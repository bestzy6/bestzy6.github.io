<!doctype html><html lang=zh-Hans x-data :class=$store.darkMode.class() :data-theme=$store.darkMode.theme()><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>如何构建高效稳健的异步任务调度系统 | Bestzy's Blog</title><link href=/favicon.ico rel=icon type=image/x-icon><link rel=canonical href=https://bestzy6.github.io/posts/task-scheduling-system/><meta name=author content="bestzy"><meta name=description content="我构建了一套通用的异步任务调度系统。它不仅能满足典型调度系统的业务逻辑，更具备高度的可扩展性和可维护性。
"><meta name=keywords content="System Design"><meta name=generator content="Hugo 0.148.2"><meta property="og:url" content="https://bestzy6.github.io/posts/task-scheduling-system/"><meta property="og:site_name" content="Bestzy's Blog"><meta property="og:title" content="如何构建高效稳健的异步任务调度系统"><meta property="og:description" content="我构建了一套通用的异步任务调度系统。它不仅能满足典型调度系统的业务逻辑，更具备高度的可扩展性和可维护性。"><meta property="og:locale" content="zh_Hans"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-17T21:18:28+08:00"><meta property="article:modified_time" content="2025-08-17T21:18:28+08:00"><meta property="article:tag" content="System Design"><meta property="og:image" content="https://bestzy6.github.io/me/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bestzy6.github.io/me/og.png"><meta name=twitter:title content="如何构建高效稳健的异步任务调度系统"><meta name=twitter:description content="我构建了一套通用的异步任务调度系统。它不仅能满足典型调度系统的业务逻辑，更具备高度的可扩展性和可维护性。"><link rel=stylesheet href=/css/output.min.css><style>pre{padding:1em;overflow:auto}</style><script defer src=https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js integrity="sha256-PtHu0lJIiSHfZeNj1nFd6wTX+Squ255SGZ/fc8seCtM=" crossorigin=anonymous></script><meta name=referrer content="no-referrer"></head><body x-data="{
    flip: false,
  }"><div id=dream-global-bg></div><nav x-data="{ isSticky: false }" x-init="window.addEventListener('scroll', () => { isSticky = window.scrollY > 30 })" class="sticky top-0 z-30 mt-4 lg:mt-8 py-4" :class="{ 'bg-base-100 shadow-lg dark:border-b dark:border-base-content/30': isSticky }"><div class="container flex justify-between px-4"><section class="flex items-center gap-4"><div class="avatar cursor-pointer hover:avatar-online" @click="flip = !flip" title=翻转一下！><div class="h-10 rounded-full"><img src="https://avatars.githubusercontent.com/u/43753176?v=4" alt=Bestzy></div></div><div><a href=https://bestzy6.github.io/ class="text-lg font-semibold cursor-pointer">Bestzy</a><div class="text-base-content/60 text-sm">🚀先行其事，后臻其善，再求其优！</div></div></section><div class="dropdown dropdown-end sm:hidden"><div tabindex=0 role=button class="btn btn-ghost btn-square" aria-label="Select an option"><ion-icon name=menu class=text-2xl></ion-icon></div><ul tabindex=0 class="dropdown-content menu w-36 bg-base-100 rounded-box z-1 shadow-md"><li><a class="group inline-flex items-center p-2 cursor-pointer" href=/search title=搜索><ion-icon name=search></ion-icon>搜索</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/index.xml title=RSS><ion-icon name=logo-rss></ion-icon>RSS</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/posts title=归档><ion-icon name=archive></ion-icon>归档</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/categories title=所有分类><ion-icon name=grid></ion-icon>所有分类</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/tags title=所有标签><ion-icon name=pricetags></ion-icon>所有标签</a></li></ul></div><section class="hidden sm:flex sm:items-center sm:gap-2 md:gap-4"><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href=/search title=搜索><ion-icon class=group-hover:text-primary-content name=search></ion-icon></a><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href=/index.xml title=RSS><ion-icon class=group-hover:text-primary-content name=logo-rss></ion-icon></a><div class="dropdown dropdown-end dropdown-hover"><div tabindex=0 role=button class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" aria-label="Select an option"><ion-icon class="group-hover:text-primary-content text-xl" name=menu></ion-icon></div><ul tabindex=0 class="dropdown-content menu w-36 bg-base-100 rounded-box z-1 shadow-xl"><li><a class="inline-flex items-center p-2 cursor-pointer" href=/posts title=归档><ion-icon name=archive></ion-icon>归档</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/categories title=所有分类><ion-icon name=grid></ion-icon>所有分类</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/tags title=所有标签><ion-icon name=pricetags></ion-icon>所有标签</a></li></ul></div></section></div></nav><div class=flip-container :class="{ 'flip-it': flip }"><div class=flipper><div class=front><div class=container><div class="lg:grid lg:grid-cols-4 gap-4 mt-4 px-4"><div class="hidden lg:block"></div><div class=lg:col-span-2><article class="mx-auto prose prose-quoteless dark:prose-invert" id=dream-single-post-main itemscope itemtype=http://schema.org/Article><meta itemprop=name content="如何构建高效稳健的异步任务调度系统"><meta itemprop=description content="我构建了一套通用的异步任务调度系统。它不仅能满足典型调度系统的业务逻辑，更具备高度的可扩展性和可维护性。"><meta itemprop=datePublished content="2025-08-17T21:18:28+08:00"><meta itemprop=dateModified content="2025-08-17T21:18:28+08:00"><meta itemprop=wordCount content="5126"><meta itemprop=image content="https://bestzy6.github.io/me/og.png"><meta itemprop=keywords content="System Design"><header><h1 itemprop=headline>如何构建高效稳健的异步任务调度系统</h1><p class=text-sm><span data-format=luxon>2025-08-17T21:18:28+08:00</span>
| <span>11分钟阅读</span></p><div class="flex justify-between"><div class="flex items-center"><div class="avatar mr-1"><div class="w-8 rounded-full"><img class=my-0! src="https://avatars.githubusercontent.com/u/43753176?v=4" alt=bestzy></div></div><span itemprop=author itemscope itemtype=https://schema.org/Person><span itemprop=name>bestzy</span></span></div><div class="flex items-center gap-2"><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="https://x.com/intent/post?text=%e5%a6%82%e4%bd%95%e6%9e%84%e5%bb%ba%e9%ab%98%e6%95%88%e7%a8%b3%e5%81%a5%e7%9a%84%e5%bc%82%e6%ad%a5%e4%bb%bb%e5%8a%a1%e8%b0%83%e5%ba%a6%e7%b3%bb%e7%bb%9f&amp;url=https://bestzy6.github.io/posts/task-scheduling-system/" target=_blank rel="noopener noreferrer" title="Share on X"><ion-icon class=group-hover:text-primary-content name=logo-x></ion-icon></a><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="https://facebook.com/sharer/sharer.php?u=https://bestzy6.github.io/posts/task-scheduling-system/" target=_blank rel="noopener noreferrer" title="Share on Facebook"><ion-icon class=group-hover:text-primary-content name=logo-facebook></ion-icon></a></div></div></header><section id=dream-single-post-content itemprop=articleBody><img class="w-full z-30" src=https://i0.hdslb.com/bfs/openplatform/f3c8be703e0f7ab847d607011b66068dc858aea9.jpg alt=如何构建高效稳健的异步任务调度系统><p>我构建了一套通用的异步任务调度系统。它不仅能满足典型调度系统的业务逻辑，更具备高度的可扩展性和可维护性。</p><h2 id=前言>前言</h2><p>在现代业务系统中，异步任务处理是不可或缺的一环。尤其在面临诸如<strong>文档解析</strong>、<strong>消息队列消费</strong>等耗时操作时，将这些任务从主业务流程中解耦，进行独立异步处理，能够显著提升系统响应速度和用户体验。</p><p>一个典型的场景便是<strong>文档解析</strong>系统，任务往往由唯一的文件ID与文件版本共同标识。</p><p>设计此类系统并非易事，我们需要考量多重复杂逻辑，例如：</p><ul><li><strong>版本冗余处理</strong>：如何应对同任务多次发起或过低版本请求？</li><li><strong>任务生命周期管理</strong>：解析超时、失败后的状态流转与重试机制。</li><li><strong>资源并发限制</strong>：如何高效控制同时处理的任务数量，避免系统过载？</li><li><strong>任务优先级调度</strong>：如何确保高优先级任务优先执行，同时避免低优先级任务饥饿？</li><li><strong>数据一致性与对账</strong>：系统异常（如解析服务宕机）后，如何恢复正确状态？</li></ul><p>面对这些挑战，我构建了一套通用的异步任务调度系统。它不仅能满足上述需求，更具备高度的可扩展性和可维护性。</p><p><img src=https://i0.hdslb.com/bfs/openplatform/117d03ff0322f9ed916cc911de6b86ef312be7cd.png alt></p><h2 id=整体架构图>整体架构图</h2><p>总体而言，任务调度系统基于面向对象的思路设计，遵循清晰的职责分离原则，将核心功能划分为若干领域模块。系统的核心组件包括：</p><ol><li>任务入库器 (Task Inserter)；</li><li>任务推送器 (Task Pusher) ；</li><li>任务回调处理器 (Task Result Receiver)。</li></ol><p>以及提供基础支撑的</p><ol><li>并发限制器 (Concurrency Limiter)</li><li>任务触发器 (Task Trigger)</li></ol><p>通过模块间的协作，系统能够实现任务的接收、持久化、调度、并发控制、结果处理以及生命周期管理。</p><p>系统主要结构如下图。</p><p><img src=https://i0.hdslb.com/bfs/openplatform/1e4ec60889bb2d89f3001e5fb67370c20ec492e5.png alt></p><h2 id=领域模型设计>领域模型设计</h2><p>清晰的领域模型是构建稳定系统的基石。我们定义了以下核心数据结构：</p><h3 id=任务-task>任务 Task</h3><p>考虑到任务的唯一性，我使用task_id、task_version来标记唯一任务。</p><p>使用payload来代表任务携带的信息，result表示任务的处理结果。</p><p>priority表示任务优先级，使用1表示高优先级，5表示低优先级，其中2~4为预留优先级。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Task</span> <span style=color:#66d9ef>struct</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>TaskId</span>         <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>TaskVersion</span>    <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Priority</span>       <span style=color:#66d9ef>int8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Payload</span>        []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=任务结果-taskresult>任务结果 TaskResult</h3><p>任务处理完成后，需要一个结构化的方式来封装处理结果，包括处理状态、状态信息及实际结果数据。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>TaskResult</span> <span style=color:#66d9ef>struct</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>StatusCode</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>StatusMsg</span>  <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Result</span>     []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=任务状态-taskstatus>任务状态 TaskStatus</h3><p>一个任务会经历一系列状态变化，我定义了以下几种核心状态，以精确反映任务在其生命周期中的位置：</p><ul><li>**Pending (待处理)：**任务已入库，等待被调度执行。</li><li>**Processing (处理中)：**任务已被处理，正在执行。</li><li>**Success (已成功)：**任务已成功完成。</li><li>**Failed (已失败)：**任务执行失败。</li><li>**Stopped (已结束)：**任务生命周期结束，可被清理。</li></ul><p>任务状态流转图如下所示：</p><p><img src=https://i0.hdslb.com/bfs/openplatform/5548ab84ce1346e973e6c0acc51901ba101fbdc8.png alt></p><p><strong>关于 Success 状态转换为 Stopped 的说明</strong>：</p><p>在我的设计中，Success状态并非任务的终态。处于这种状态的任务，通常会保留一段时间（例如缓存周期24小时），以便后续重复查询。当达到预设的保留时间后，任务状态将转换为 Stopped。</p><p>Stopped 状态意味着该任务的生命周期已物理性结束，可以随时被系统清理（即从数据库中删除）。这种设计有助于精细化管理任务的生命周期，平衡数据保留与系统资源消耗。</p><h2 id=通用数据表设计>通用数据表设计</h2><p>系统采用关系型数据库进行任务的持久化。</p><table><thead><tr><th>序号</th><th>字段名称</th><th>字段类型</th><th>字段说明</th></tr></thead><tbody><tr><td>1</td><td>id</td><td>bigint</td><td>主键</td></tr><tr><td>2</td><td>task_id</td><td>bigint</td><td>任务id</td></tr><tr><td>3</td><td>task_version</td><td>bigint</td><td>任务版本</td></tr><tr><td>4</td><td>status</td><td>int</td><td>任务状态</td></tr><tr><td>5</td><td>create_at</td><td>bigint</td><td>创建时间戳</td></tr><tr><td>6</td><td>update_at</td><td>bigint</td><td>修改时间戳</td></tr><tr><td>7</td><td>payload</td><td>TEXT</td><td>任务载荷（信息）</td></tr><tr><td>8</td><td>result</td><td>TEXT</td><td>任务处理结果</td></tr></tbody></table><p>关键优化点提示：</p><ul><li><strong>payload</strong> <strong>和 result 字段</strong>：考虑到其可能存储大量数据，强烈建议使用 TEXT (对于字符串) 或 BLOB (对于二进制数据) 类型，而非 VARCHAR。对于超出数据库单字段存储限制（如MySQL的4GB）的超大载荷，应考虑将其存储在对象存储（如S3、OSS）中，并在数据库中仅记录对应的Key或URL。</li><li>create_at 和 update_at：使用 BIGINT 存储Unix时间戳（毫秒或纳秒），便于排序和计算，且不受数据库时区配置影响。</li><li>增加 status_msg 字段用于存储更详细的状态信息，尤其是失败时的错误详情，这对于问题排查至关重要。</li></ul><h2 id=业务逻辑设计>业务逻辑设计</h2><h3 id=taskinserter>TaskInserter</h3><p>Task Inserter 模块负责接收外部的任务发起请求，并将其持久化到数据库中。在分布式和高并发环境下，<strong>它必须具备高度的健壮性以处理各种异常情况</strong>，尤其要实现幂等性和版本控制。</p><p><strong>处理场景与策略</strong>：</p><ul><li><strong>多次收到相同任务发起请求</strong>：通过 task_id 和 task_version 联合唯一索引来判断任务是否已存在。如果已存在且任务状态为Pending、Failed、Stopped，则删除原有任务并新增，否则直接返回现有任务信息，避免重复入库和重复处理。</li><li><strong>收到低版本的任务发起请求</strong>：如果数据库中已存在更高版本的 task_id 任务，则拒绝或忽略当前低版本任务的入库请求。</li><li><strong>低版本任务未处理完，收到高版本任务</strong>：允许入库。系统会优先处理高版本任务（通过 TaskPusher 的优先级策略）。</li></ul><p><strong>核心思想</strong>：避免无效的任务入库与处理，节约系统资源。</p><p>入库流程图如下所示：</p><pre class=mermaid>
  graph TD
    A[Start: AddTask] --&gt; E[查询同task_id版本&gt;=当前的任务任务]
    E --&gt; F[pickLatestTask获取最新任务]
    F --&gt; G{是否存在最新任务?}
    G --&gt;|否| H[initSave保存任务]
    G --&gt;|是| I{最新任务版本比较}
    I --&gt;|大于当前版本| J[handleHigherVersionTask]
    I --&gt;|等于当前版本| K[handleEqualVersionTask]
    
    %% 高版本任务处理
    J --&gt; L{任务状态?}
    L --&gt;|Pending/Processing| M[记录日志并返回]
    L --&gt;|Success| N[返回]
    
    %% 同版本任务处理
    K --&gt; O{任务状态?}
    O --&gt;|Processing| P[记录日志并返回]
    O --&gt;|Success| Q[返回]
    O --&gt;|Pending| R[initSave保存任务]
</pre><h3 id=taskpusher>TaskPusher</h3><p>Task Pusher 负责从数据库中拉取待处理 (Pending) 的任务，并将其推送至Worker。其关键在于如何有效获取任务以及避免低优先级任务的饥饿。</p><p>由“任务推送触发器”控制TaskPusher拉取任务，拉取任务的过程如下图所示。</p><pre class=mermaid>
  graph TD
    A[TaskPusher] --&gt; E[获取剩余限制任务数restN]
    E --&gt; F{restN &gt; 0?}
    F --&gt;|否| G[记录日志并返回]
    F --&gt;|是| H[通过chooser获取待处理任务]
    H --&gt; I{遍历获取的任务}
    I --&gt;|每个任务| J[处理任务]
    
    %% handleTask流程
    J --&gt; K[增加并发计数]
    K --&gt; L{并发计数成功?}
    L --&gt;|失败| M[返回错误]
    L --&gt;|成功| N[尝试更新任务状态为Processing]
    
    N --&gt; O{状态更新成功?}
    O --&gt;|行数为0| P[减少并发计数后返回]
    O --&gt;|成功| Q[发送任务]
    
    Q --&gt; R{任务发送成功?}
    R --&gt;|成功| S[记录日志后返回]
    R --&gt;|失败| T[更新状态为Failed]
    T --&gt; U[减少并发计数]
    
    classDef main fill:#e6f7ff,stroke:#333,stroke-width:1px;
    classDef branch fill:#f9f2f4,stroke:#333,stroke-width:1px;
    classDef subflow fill:#f0f7ee,stroke:#333,stroke-width:1px;
    
    class A main;
    class F,O,R branch;
    class Q subflow;
</pre><h4 id=防饥饿策略高低优先级混合调度>防饥饿策略：高/低优先级混合调度</h4><p>本系统目前仅包含高、低两种优先级（可通过扩展支持更多）。我们采用了一种简单而有效的概率性调度策略来兼顾公平性（对应图中Chooser）：</p><ul><li><strong>80%</strong> 的概率执行高优先级任务拉取SQL：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> id <span style=color:#66d9ef>FROM</span> tb <span style=color:#66d9ef>WHERE</span> status<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Pending&#39;</span> <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> priority <span style=color:#66d9ef>ASC</span>, id <span style=color:#66d9ef>ASC</span> <span style=color:#66d9ef>LIMIT</span> N;
</span></span></code></pre></div><p>这条SQL会优先选择 priority 值最小（最高优先级）的任务，并在优先级相同的情况下，按照 id 升序（即创建时间顺序）选择最老的任务。</p><ul><li><strong>20%</strong> 的概率执行低优先级任务拉取SQL：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> id <span style=color:#66d9ef>FROM</span> tb <span style=color:#66d9ef>WHERE</span> status<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Pending&#39;</span> <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> priority <span style=color:#66d9ef>DESC</span>, id <span style=color:#66d9ef>ASC</span> <span style=color:#66d9ef>LIMIT</span> N;
</span></span></code></pre></div><p>这条SQL会优先选择 priority 值最大（最低优先级）的任务。</p><p>这种方式保证了每次拉取任务的数量都不为0，例如高优先级任务队列为空时，两种情况都会自然地拉取到低优先级任务。</p><p>通过这种加权轮询的方式，既保证了高优先级任务能及时得到处理，又确保了低优先级任务有被执行的机会，有效避免了饥饿现象。拉取到的任务会在数据库中立即将其状态更改为 Processing。</p><h3 id=taskresultreceiver>TaskResultReceiver</h3><p>Task Result Receiver 负责接收外部 Worker 处理完成后的任务结果回调。这是任务生命周期中的关键一环，它将影响任务的最终状态及并发控制。</p><p>处理流程：</p><ol><li>接收 Worker 发送的任务处理结果 (包含 task_id, task_version, task_result 等)。</li><li>根据 task_id 和 task_version 精准定位到数据库中的任务记录。</li><li><strong>原子性更新</strong>任务状态 (Success 或 Failed)、更新 result、status_msg 以及 update_at 字段。</li><li><strong>仅当数据库状态更新成功后</strong>，才通知“任务并发限制器”减少当前 Processing 任务的数量。这确保了计数的准确性，防止在数据库操作失败时导致并发计数出现偏差。</li></ol><h3 id=taskwatcher>TaskWatcher</h3><p>Task Watcher 是系统健壮性的重要保障，它以<strong>定时任务</strong>的形式运行，负责监控并处理任务的异常状态和过期任务的清理。</p><p>监控职责：</p><ul><li><strong>Pending 任务超时失败</strong>：当任务长时间处于 Pending 状态，超过预设的 PendingExpiredTime，表明该任务可能因某种异常（如推送器故障、无可用Worker等）未能被及时处理。Watcher 会将其状态转变为 Failed。</li><li><strong>Processing 任务超时失败</strong>：当任务被 Worker 领取后，长时间处于 Processing 状态，超过预设的 ProcessingExpiredTime，表明Worker可能已宕机、处理卡死或网络中断，未能及时回调。Watcher 会将其状态转变为 Failed，并确保 <strong>并发限制器</strong> 的计数得到修正。</li><li><strong>Success 任务转为 Stopped</strong>：当任务成功完成并已达到 SuccessExpiredTime（即其结果缓存期已过），Watcher 会将其状态转变为 Stopped，标记为可清理。</li><li><strong>定时物理删除过期任务</strong>：Watcher 会定期扫描处于 Failed 或 Stopped 状态且 update_at 时间已达到可配置的清理周期（N天） 的任务，将其从数据库中物理删除，释放存储空间。</li></ul><h2 id=基础设施设计>基础设施设计</h2><h3 id=任务并发限制器>任务并发限制器</h3><p>并发限制器是确保系统稳定运行的关键。它用于控制系统中同时处于 Processing 状态的任务总数，防止任务处理服务过载。</p><ul><li><strong>存储介质</strong>：使用 Redis-String 存储。Value 表示当前处理中的任务数量。Redis 具有原子操作和高性能的特点，非常适合分布式场景下的计数。为确保原子增减值的上下限，需要<strong>使用Lua脚本</strong>保证Redis命令的原子性。</li><li><strong>操作</strong>：<ul><li>当 TaskPusher 成功将任务状态从 Pending 更新为 Processing 时，通过 Redis 的 INCR 命令原子性地增加计数。在 INCR 前，会检查当前计数是否已达到最大并发限制。</li><li>当 TaskResult Receiver 成功将任务状态从 Processing 更新为 Success 或 Failed 时，通过 Redis 的 DECR 命令原子性地减少计数。</li></ul></li><li><strong>对账机制</strong>：为了应对解析服务宕机、异常退出或其他原因导致Redis计数器与数据库实际状态不一致的问题，系统会每隔 T 时间（可配置）与数据库进行一次对账。<ul><li><strong>对账逻辑</strong>：统计数据库中 status=&lsquo;Processing&rsquo; 的任务数量，然后用这个真实数量强制更新Redis Value值。这能够确保即使在极端情况下，并发计数也能及时校准，保证系统长时间运行的稳定性。</li></ul></li></ul><h3 id=任务推送触发器>任务推送触发器</h3><p>任务推送触发器负责异步唤醒 Task Pusher 从数据库中拉取并处理任务。</p><p>触发时机：</p><ol><li><strong>任务成功入库后</strong>：当 Task Inserter 成功将新任务写入数据库后，立即触发一次 Task Pusher 尝试推送任务。这保证了新任务能够被及时发现并处理。</li><li><strong>周期性触发</strong>：每隔 N 间隔时间（例如：每5秒）触发一次 Task Pusher。这是一个兜底机制，即使事件触发失败也能保证任务被周期性地检测和推送，防止任务堆积。</li><li><strong>任务成功回调后</strong>：当 Task Result Receiver 接收到任务完成回调并更新状态后，也触发一次 Task Pusher。这表示有空闲的并发槽位被释放，可以立即尝试处理新的任务。</li></ol><h2 id=更多思考与系统增强>更多思考<strong>与系统增强</strong></h2><p>作为一个生产级的任务调度系统，我们还需要考虑以下高级特性与优化。</p><h3 id=重试>重试</h3><p>在许多业务场景下，任务失败后需要进行重试。本方案可以通过以下方式扩展支持重试：</p><ol><li><strong>数据库字段</strong>：在 task_scheduler_tasks 表中增加 retry_count (当前重试次数) 和 max_retries (最大重试次数) 字段。</li><li><strong>失败状态处理</strong>：当任务失败 (Failed) 且 retry_count &lt; max_retries 时：<ol><li>不直接转为 Stopped。</li><li>将 retry_count 增加1。</li><li>根据预设的重试策略（立即重试、固定间隔重试、指数退避重试等），将任务状态重新置为 Pending，并根据重试策略更新 create_at 或设置一个 next_retry_time。</li><li>可以为重试任务设置一个稍低的优先级，避免重试任务阻塞新任务。</li></ol></li><li><strong>专属TaskPusher</strong>：对于重试任务，可以考虑为其设置专属TaskPusher，实现资源隔离。</li></ol><h3 id=多优先级><strong>多优先级</strong></h3><p>当任务优先级大于两种时，简单的概率策略可能不足。可以考虑更复杂的调度算法：</p><ul><li><strong>权重队列</strong>：为每个优先级分配不同的权重，根据权重比例从相应队列中拉取任务。</li><li><strong>调度算法</strong>：在每次拉取任务时，通过加权随机算法选择要读取的优先级区间。</li></ul><p>但需要关注某权重任务为空的情况，出现该情况时，建议立即更换权重。</p><h3 id=可伸缩性><strong>可伸缩性</strong></h3><p>为应对快速变化的业务，可伸缩性极其重要，为避免多实例造成影响。</p><ul><li><strong>任务并发限制器</strong>：多个实例共用限制器，避免任务处理的并发数过大。</li><li><strong>定时任务</strong>：定时任务增加分布式锁，避免多个定时任务同时执行。</li><li><strong>数据库原子性</strong>：使用update原子操作避免相同任务被多实例发送。</li></ul><h3 id=可观察性><strong>可观察性</strong></h3><p>一个生产级系统必须具备完善的可观察性，根据项目上线后的经验，建议添加以下观察项：</p><ul><li>日志 (Logging) ：详细记录任务的生命周期、状态变更、错误信息、性能数据。</li><li>指标 (Metrics) ：暴露关键指标到监控系统 (如Prometheus)：<ul><li><code>Pending/Processing/Success/Failed</code> 任务数量。</li><li>任务处理耗时分布。</li><li>并发限制器当前值。</li></ul></li><li>链路追踪 (Tracing) ：系统中各模块均异步处理，容易将任务由入库到完成的链路打断，导致问题排查困难，建议补齐完成链路。</li></ul><h2 id=总结><strong>总结</strong></h2><p>本文详细阐述了一个异步任务调度系统设计，涵盖了核心领域模型、数据库设计、业务逻辑处理以及关键基础设施。通过引入任务版本管理、优先级调度、并发限制、超时监控与自动清理等机制，我们构建了一个健壮、高效且具备高可扩展性的异步任务处理平台。</p><p>该系统能够有效解决异步任务管理面临的诸多挑战，确保任务的可靠执行与资源的合理利用。</p></section><div class=divider></div><section class=space-y-4><template x-if="['localhost', '127.0.0.1'].indexOf(window.location.hostname) == -1"><article><script src=https://utteranc.es/client.js repo=bestzy6/bestzy6.github.io issue-term=og:title theme=github-light crossorigin=anonymous async></script></article></template></section></article></div><div x-data=tocHighlighter() @scroll.window=debouncedScroll class="hidden lg:flex lg:flex-col lg:items-end"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#整体架构图>整体架构图</a></li><li><a href=#领域模型设计>领域模型设计</a><ul><li><a href=#任务-task>任务 Task</a></li><li><a href=#任务结果-taskresult>任务结果 TaskResult</a></li><li><a href=#任务状态-taskstatus>任务状态 TaskStatus</a></li></ul></li><li><a href=#通用数据表设计>通用数据表设计</a></li><li><a href=#业务逻辑设计>业务逻辑设计</a><ul><li><a href=#taskinserter>TaskInserter</a></li><li><a href=#taskpusher>TaskPusher</a></li><li><a href=#taskresultreceiver>TaskResultReceiver</a></li><li><a href=#taskwatcher>TaskWatcher</a></li></ul></li><li><a href=#基础设施设计>基础设施设计</a><ul><li><a href=#任务并发限制器>任务并发限制器</a></li><li><a href=#任务推送触发器>任务推送触发器</a></li></ul></li><li><a href=#更多思考与系统增强>更多思考<strong>与系统增强</strong></a><ul><li><a href=#重试>重试</a></li><li><a href=#多优先级><strong>多优先级</strong></a></li><li><a href=#可伸缩性><strong>可伸缩性</strong></a></li><li><a href=#可观察性><strong>可观察性</strong></a></li></ul></li><li><a href=#总结><strong>总结</strong></a></li></ul></nav></div></div><footer class="flex justify-between items-center gap-2 px-4 py-12"><div><p>© 2025 Bestzy's Blog</p><p class=text-sm>🌱
<span class=text-base-content/60>Powered by <a class=hover:underline href=https://gohugo.io/ target=_blank>Hugo</a> with theme
<a class=hover:underline href=https://github.com/g1eny0ung/hugo-theme-dream target=_blank>Dream</a>.</span></p></div><div x-data="{ icons: [
    { name: 'sunny', status: 'n' },
    { name: 'moon', status: 'y' },
    { name: 'desktop', status: 'auto' }
  ] }" class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"><template x-for="icon in icons"><div role=button tabindex=0 :aria-label="'Select ' + icon.name + ' mode'" class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary" :class="$store.darkMode.icon() === icon.name && 'bg-primary'" @click=$store.darkMode.toggle(icon.status)><ion-icon :name="`${icon.name}-outline`" class=group-hover:text-primary-content :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"></ion-icon></div></template></div></footer></div></div><div class=back><div class=container><div class="dream-grid dream-grid-about"><div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column"><article class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"><div class=card-body><div class=card-title>About Me</div><div class="prose dark:prose-invert"><p>👋 Hi, This is Zheng Yi.</p></div></div></article></div></div><footer class="flex justify-between items-center gap-2 px-4 py-12"><div><p>© 2025 Bestzy's Blog</p><p class=text-sm>🌱
<span class=text-base-content/60>Powered by <a class=hover:underline href=https://gohugo.io/ target=_blank>Hugo</a> with theme
<a class=hover:underline href=https://github.com/g1eny0ung/hugo-theme-dream target=_blank>Dream</a>.</span></p></div><div x-data="{ icons: [
    { name: 'sunny', status: 'n' },
    { name: 'moon', status: 'y' },
    { name: 'desktop', status: 'auto' }
  ] }" class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"><template x-for="icon in icons"><div role=button tabindex=0 :aria-label="'Select ' + icon.name + ' mode'" class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary" :class="$store.darkMode.icon() === icon.name && 'bg-primary'" @click=$store.darkMode.toggle(icon.status)><ion-icon :name="`${icon.name}-outline`" class=group-hover:text-primary-content :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"></ion-icon></div></template></div></footer></div></div></div></div><script>window.lightTheme="emerald",window.darkTheme="forest"</script><script src=https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin=anonymous></script><script src=/js/grid.min.js></script><script src=/js/main.min.js></script><script src=https://cdn.jsdelivr.net/npm/luxon@1.26.0 integrity="sha256-4sbTzmCCW9LGrIh5OsN8V5Pfdad1F1MwhLAOyXKnsE0=" crossorigin=anonymous></script><script>format();function format(){document.querySelectorAll('span[data-format="luxon"]').forEach(e=>{const t=e.textContent;e.textContent=luxon.DateTime.fromISO(t,{locale:"zh"}).toFormat("yyyy年MM月dd日")})}</script><script src=/js/toc.min.js></script><script type=module>
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true });
      </script><script async src="https://www.googletagmanager.com/gtag/js?id=G-BR16XEQ6Y4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BR16XEQ6Y4")}</script><script type=module src=https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.esm.js integrity="sha256-/IFmi82bIhdYWctu0UddSlJqpnzWm7Vh2C4CM32wF/k=" crossorigin=anonymous></script><script nomodule src=https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.js integrity="sha256-mr7eJMX3VC3F7G32mk4oWp1C6a2tlMYxUdptfT7uKI8=" crossorigin=anonymous></script></body></html>