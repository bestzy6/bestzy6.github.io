<!doctype html><html lang=zh-Hans x-data :class=$store.darkMode.class() :data-theme=$store.darkMode.theme()><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>MySQL分页查询踩坑记：从物理存储到结果排序的思考 | Bestzy's Blog</title>
<link href=/favicon.ico rel=icon type=image/x-icon><link rel=canonical href=https://bestzy6.github.io/posts/mysql-pagination-query-pitfalls/><meta name=author content="bestzy"><meta name=description content="最近在处理一个分页查询时，遇到了结果集顺序不确定的问题，这引发了我对 MySQL 查询执行模型的思考。
"><meta name=keywords content="Mysql"><meta name=generator content="Hugo 0.145.0"><meta property="og:url" content="https://bestzy6.github.io/posts/mysql-pagination-query-pitfalls/"><meta property="og:site_name" content="Bestzy's Blog"><meta property="og:title" content="MySQL分页查询踩坑记：从物理存储到结果排序的思考"><meta property="og:description" content="最近在处理一个分页查询时，遇到了结果集顺序不确定的问题，这引发了我对 MySQL 查询执行模型的思考。"><meta property="og:locale" content="zh_Hans"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-22T23:07:11+08:00"><meta property="article:modified_time" content="2025-01-22T23:07:11+08:00"><meta property="article:tag" content="Mysql"><meta property="og:image" content="https://bestzy6.github.io/me/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bestzy6.github.io/me/og.png"><meta name=twitter:title content="MySQL分页查询踩坑记：从物理存储到结果排序的思考"><meta name=twitter:description content="最近在处理一个分页查询时，遇到了结果集顺序不确定的问题，这引发了我对 MySQL 查询执行模型的思考。"><link rel=stylesheet href=/css/output.min.css><style>pre{padding:1em;overflow:auto}</style><script defer src=https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js integrity="sha256-PtHu0lJIiSHfZeNj1nFd6wTX+Squ255SGZ/fc8seCtM=" crossorigin=anonymous></script><meta name=referrer content="no-referrer"></head><body x-data="{
    flip: false,
  }"><div id=dream-global-bg></div><nav x-data="{ isSticky: false }" x-init="window.addEventListener('scroll', () => { isSticky = window.scrollY > 30 })" class="sticky top-0 z-30 mt-4 lg:mt-8 py-4" :class="{ 'bg-base-100 shadow-lg dark:border-b dark:border-base-content/30': isSticky }"><div class="container flex justify-between px-4"><section class="flex items-center gap-4"><div class="avatar cursor-pointer hover:avatar-online" @click="flip = !flip" title=翻转一下！><div class="h-10 rounded-full"><img src="https://avatars.githubusercontent.com/u/43753176?v=4" alt=Bestzy></div></div><div><a href=https://bestzy6.github.io/ class="text-lg font-semibold cursor-pointer">Bestzy</a><div class="text-base-content/60 text-sm">🚀先行其事，后臻其善，再求其优！</div></div></section><div class="dropdown dropdown-end sm:hidden"><div tabindex=0 role=button class="btn btn-ghost btn-square" aria-label="Select an option"><ion-icon name=menu class=text-2xl></ion-icon></div><ul tabindex=0 class="dropdown-content menu w-36 bg-base-100 rounded-box z-1 shadow-md"><li><a class="group inline-flex items-center p-2 cursor-pointer" href=/search title=搜索><ion-icon name=search></ion-icon>搜索</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/index.xml title=RSS><ion-icon name=logo-rss></ion-icon>RSS</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/posts title=归档><ion-icon name=archive></ion-icon>归档</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/categories title=所有分类><ion-icon name=grid></ion-icon>所有分类</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/tags title=所有标签><ion-icon name=pricetags></ion-icon>所有标签</a></li></ul></div><section class="hidden sm:flex sm:items-center sm:gap-2 md:gap-4"><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href=/search title=搜索><ion-icon class=group-hover:text-primary-content name=search></ion-icon></a><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href=/index.xml title=RSS><ion-icon class=group-hover:text-primary-content name=logo-rss></ion-icon></a><div class="dropdown dropdown-end dropdown-hover"><div tabindex=0 role=button class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" aria-label="Select an option"><ion-icon class="group-hover:text-primary-content text-xl" name=menu></ion-icon></div><ul tabindex=0 class="dropdown-content menu w-36 bg-base-100 rounded-box z-1 shadow-xl"><li><a class="inline-flex items-center p-2 cursor-pointer" href=/posts title=归档><ion-icon name=archive></ion-icon>归档</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/categories title=所有分类><ion-icon name=grid></ion-icon>所有分类</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/tags title=所有标签><ion-icon name=pricetags></ion-icon>所有标签</a></li></ul></div></section></div></nav><div class=flip-container :class="{ 'flip-it': flip }"><div class=flipper><div class=front><div class=container><div class="lg:grid lg:grid-cols-4 gap-4 mt-4 px-4"><div class="hidden lg:block"></div><div class=lg:col-span-2><article class="mx-auto prose prose-quoteless dark:prose-invert" id=dream-single-post-main itemscope itemtype=http://schema.org/Article><meta itemprop=name content="MySQL分页查询踩坑记：从物理存储到结果排序的思考"><meta itemprop=description content="最近在处理一个分页查询时，遇到了结果集顺序不确定的问题，这引发了我对 MySQL 查询执行模型的思考。"><meta itemprop=datePublished content="2025-01-22T23:07:11+08:00"><meta itemprop=dateModified content="2025-01-22T23:07:11+08:00"><meta itemprop=wordCount content="1963"><meta itemprop=image content="https://bestzy6.github.io/me/og.png"><meta itemprop=keywords content="Mysql"><header><h1 itemprop=headline>MySQL分页查询踩坑记：从物理存储到结果排序的思考</h1><p class=text-sm><span data-format=luxon>2025-01-22T23:07:11+08:00</span>
| <span>4分钟阅读</span>
| <span>更新于
<span data-format=luxon>2025-01-22T23:07:11+08:00</span></span></p><div class="flex justify-between"><div class="flex items-center"><div class="avatar mr-1"><div class="w-8 rounded-full"><img class=my-0! src="https://avatars.githubusercontent.com/u/43753176?v=4" alt=bestzy></div></div><span itemprop=author itemscope itemtype=https://schema.org/Person><span itemprop=name>bestzy</span></span></div><div class="flex items-center gap-2"><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="https://x.com/intent/post?text=MySQL%e5%88%86%e9%a1%b5%e6%9f%a5%e8%af%a2%e8%b8%a9%e5%9d%91%e8%ae%b0%ef%bc%9a%e4%bb%8e%e7%89%a9%e7%90%86%e5%ad%98%e5%82%a8%e5%88%b0%e7%bb%93%e6%9e%9c%e6%8e%92%e5%ba%8f%e7%9a%84%e6%80%9d%e8%80%83&amp;url=https://bestzy6.github.io/posts/mysql-pagination-query-pitfalls/" target=_blank rel="noopener noreferrer" title="Share on X"><ion-icon class=group-hover:text-primary-content name=logo-x></ion-icon></a><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href="https://facebook.com/sharer/sharer.php?u=https://bestzy6.github.io/posts/mysql-pagination-query-pitfalls/" target=_blank rel="noopener noreferrer" title="Share on Facebook"><ion-icon class=group-hover:text-primary-content name=logo-facebook></ion-icon></a></div></div></header><section id=dream-single-post-content itemprop=articleBody><img class="w-full z-30" src=https://i0.hdslb.com/bfs/article/4bf998cc53acf4aa7aee16bc77c5b9b42099359.jpg alt=MySQL分页查询踩坑记：从物理存储到结果排序的思考><p>最近在处理一个分页查询时，遇到了结果集顺序不确定的问题，这引发了我对 MySQL 查询执行模型的思考。</p><h2 id=引言>引言</h2><p>在 MySQL 数据库的日常使用中，我们经常会遇到一些看似简单但实际上涉及复杂内部机制的问题。</p><p>最近在处理一个分页查询时，遇到了结果集顺序不确定的问题，这引发了我对 MySQL 查询执行模型的思考。本文将从物理存储、查询优化、执行计划等多个维度，深入分析 MySQL 的工作原理。</p><h2 id=问题引出>问题引出</h2><p>假设存在表<code>tb_foo_bar</code>，其见表语句如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> tb_foo_bar (
</span></span><span style=display:flex><span>    id INT AUTO_INCREMENT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>    company_id INT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    subject_type INT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    subject_id INT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>INDEX</span> idx_company_id (company_id,subject_type,subject_id)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>考虑以下查询：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> tb_foo_bar
</span></span><span style=display:flex><span><span style=color:#66d9ef>WHERE</span> company_id <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>AND</span> subject_type <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>LIMIT</span> <span style=color:#ae81ff>10</span> <span style=color:#66d9ef>OFFSET</span> <span style=color:#ae81ff>40</span>;
</span></span></code></pre></div><p>这个查询在不同的 <code>OFFSET</code> 值下可能出现重复的结果数据集。如 <code>OFFSET</code> 为40时结果如下：</p><table><thead><tr><th>id</th><th>company_id</th><th>subject_id</th><th>subject_type</th></tr></thead><tbody><tr><td>12</td><td>4</td><td>530</td><td>1</td></tr><tr><td>16</td><td>4</td><td>531</td><td>1</td></tr><tr><td>13</td><td>4</td><td>533</td><td>1</td></tr><tr><td>14</td><td>4</td><td>537</td><td>1</td></tr><tr><td>3</td><td>4</td><td>61</td><td>1</td></tr><tr><td>48</td><td>4</td><td>618</td><td>1</td></tr><tr><td>47</td><td>4</td><td>619</td><td>1</td></tr><tr><td>49</td><td>4</td><td>620</td><td>1</td></tr><tr><td>50</td><td>4</td><td>621</td><td>1</td></tr><tr><td>51</td><td>4</td><td>622</td><td>1</td></tr></tbody></table><p>而当<code>OFFSET</code>为50时，结果可能如下：</p><table><thead><tr><th>id</th><th>company_id</th><th>subject_id</th><th>subject_type</th></tr></thead><tbody><tr><td>12</td><td>4</td><td>530</td><td>1</td></tr><tr><td>16</td><td>4</td><td>531</td><td>1</td></tr><tr><td>13</td><td>4</td><td>533</td><td>1</td></tr><tr><td>55</td><td>4</td><td>626</td><td>1</td></tr><tr><td>56</td><td>4</td><td>627</td><td>1</td></tr><tr><td>57</td><td>4</td><td>628</td><td>1</td></tr><tr><td>58</td><td>4</td><td>629</td><td>1</td></tr><tr><td>59</td><td>4</td><td>630</td><td>1</td></tr><tr><td>61</td><td>4</td><td>631</td><td>1</td></tr><tr><td>60</td><td>4</td><td>632</td><td>1</td></tr></tbody></table><p>原因很简单，即<strong>查询语句中没有指定 ORDER BY 子句</strong>。 当 MySQL 执行这个查询时：</p><ol><li>可能使用索引<code>idx_company_id</code>；</li><li>可能进行全表扫描；</li><li>不同的 OFFSET 值可能导致优化器选择不同的执行计划。</li></ol><p>但这个现象引出了几个深层次的问题：</p><ol><li>为什么 InnoDB 的物理存储是有序的，但查询结果可能无序？</li><li>查询优化器在不同 OFFSET 值下为什么会选择不同的执行计划？</li><li>数据的访问路径如何影响最终的结果顺序？</li></ol><h2 id=一mysql的物理存储模型>一、MySQL的物理存储模型</h2><h3 id=11-innodb的聚簇索引结构>1.1 InnoDB的聚簇索引结构</h3><p>InnoDB 使用聚簇索引组织数据，这意味着：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>[数据页结构]
</span></span><span style=display:flex><span>Page Header
</span></span><span style=display:flex><span>│
</span></span><span style=display:flex><span>├── 记录1 (主键=1)
</span></span><span style=display:flex><span>├── 记录2 (主键=2)
</span></span><span style=display:flex><span>├── 记录3 (主键=3)
</span></span><span style=display:flex><span>└── ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[页间关系]
</span></span><span style=display:flex><span>Page 1 ──► Page 2 ──► Page 3 ──► ...
</span></span><span style=display:flex><span>(1-100)    (101-200)   (201-300)
</span></span></code></pre></div><h3 id=12-数据页的加载机制>1.2 数据页的加载机制</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>Buffer Pool
</span></span><span style=display:flex><span>├── LRU List
</span></span><span style=display:flex><span>│   ├── Young Page List
</span></span><span style=display:flex><span>│   └── Old Page List
</span></span><span style=display:flex><span>└── Free List
</span></span></code></pre></div><p>这种结构导致：</p><ol><li>数据物理上是有序的</li><li>但读取顺序受 Buffer Pool 状态影响</li><li>多线程并行读取时顺序更不确定</li></ol><h2 id=二查询优化器的决策模型>二、查询优化器的决策模型</h2><h3 id=21-成本估算>2.1 成本估算</h3><p>MySQL 查询优化器采用基于成本的优化策略。在处理查询时，优化器会评估多个可能的执行计划，并选择总成本最低的方案。查询优化器使用复杂的成本模型来选择执行计划：</p><pre tabindex=0><code>总成本 = 数据页读取成本 + 行检查成本 + 排序成本
</code></pre><p>其中：</p><ol><li><p>数据页读取成本</p><ul><li>内存读取成本 = 页数 × 1.0</li><li>磁盘读取成本 = 页数 × 4.0</li></ul></li><li><p>行检查成本</p><ul><li>索引检查成本 = 记录数 × 0.2</li><li>全表检查成本 = 记录数 × 0.1</li></ul></li><li><p>排序成本（如果需要）</p><ul><li>内存排序 = 记录数 × log2(记录数) × 0.1</li><li>磁盘排序 = 记录数 × log2(记录数) × 0.2</li></ul></li></ol><p>对于不同的 OFFSET：</p><ul><li>小偏移：索引扫描成本 &lt; 全表扫描成本</li><li>大偏移：索引扫描成本 > 全表扫描成本（需要扫描大量索引项）</li></ul><h3 id=22-执行计划的动态选择>2.2 执行计划的动态选择</h3><p>MySQL 优化器会根据统计信息和成本估算动态选择执行计划。</p><p>让我们通过实际的 EXPLAIN 分析来理解这个过程：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 案例分析
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>EXPLAIN</span> FORMAT<span style=color:#f92672>=</span>TREE
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> tb_foo_bar 
</span></span><span style=display:flex><span><span style=color:#66d9ef>WHERE</span> company_id <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span> 
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>AND</span> subject_type <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>LIMIT</span> <span style=color:#ae81ff>10</span> <span style=color:#66d9ef>OFFSET</span> <span style=color:#ae81ff>1000</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>可能的执行计划1（小偏移）：
</span></span></span><span style=display:flex><span><span style=color:#75715e>└── Index Scan (idx_company_subject)
</span></span></span><span style=display:flex><span><span style=color:#75715e>    └── Filter: company_id=4 AND subject_type=1
</span></span></span><span style=display:flex><span><span style=color:#75715e>        └── Limit/Offset
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>可能的执行计划2（大偏移）：
</span></span></span><span style=display:flex><span><span style=color:#75715e>└── Table Scan
</span></span></span><span style=display:flex><span><span style=color:#75715e>    └── Filter: company_id=4 AND subject_type=1
</span></span></span><span style=display:flex><span><span style=color:#75715e>        └── Limit/Offset
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><h2 id=三深入分析为什么会出现重复结果>三、深入分析：为什么会出现重复结果？</h2><h3 id=31-执行路径分析>3.1 执行路径分析</h3><p>当 MySQL 执行分页查询时，根据优化器选择的执行计划，数据访问路径可能完全不同：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>路径1（使用索引）：
</span></span><span style=display:flex><span>└── 索引扫描
</span></span><span style=display:flex><span>    ├── 1. 定位索引起始位置 (company_id=4 AND subject_type=1)
</span></span><span style=display:flex><span>    ├── 2. 顺序扫描索引记录
</span></span><span style=display:flex><span>    ├── 3. 通过主键回表获取完整记录
</span></span><span style=display:flex><span>    └── 4. 收集直到满足 OFFSET+LIMIT 条记录
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>路径2（全表扫描）：
</span></span><span style=display:flex><span>└── 表扫描
</span></span><span style=display:flex><span>    ├── 1. 从第一个数据页开始顺序扫描
</span></span><span style=display:flex><span>    ├── 2. 对每条记录应用 WHERE 条件过滤
</span></span><span style=display:flex><span>    ├── 3. 符合条件的记录进入结果集
</span></span><span style=display:flex><span>    └── 4. 直到满足 OFFSET+LIMIT 条记录
</span></span></code></pre></div><h3 id=32-结果集的构建过程>3.2 结果集的构建过程</h3><p>MySQL 在构建最终结果集时，经过多个阶段的处理：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>1. 数据获取阶段
</span></span><span style=display:flex><span>   ├── 索引扫描路径
</span></span><span style=display:flex><span>   │   ├── 按索引顺序读取（company_id, subject_type, subject_id 顺序）
</span></span><span style=display:flex><span>   │   ├── 回表获取完整记录
</span></span><span style=display:flex><span>   │   └── 结果顺序受索引结构影响
</span></span><span style=display:flex><span>   │
</span></span><span style=display:flex><span>   └── 全表扫描路径
</span></span><span style=display:flex><span>       ├── 按数据页顺序读取
</span></span><span style=display:flex><span>       ├── 应用过滤条件
</span></span><span style=display:flex><span>       └── 结果顺序受数据页存储顺序影响
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. 结果集处理阶段
</span></span><span style=display:flex><span>   ├── 内存临时表处理（sort_buffer_size 范围内）
</span></span><span style=display:flex><span>   │   ├── 存储中间结果
</span></span><span style=display:flex><span>   │   └── 可能发生内存中排序
</span></span><span style=display:flex><span>   │
</span></span><span style=display:flex><span>   └── 磁盘临时表处理（超出 sort_buffer_size）
</span></span><span style=display:flex><span>       ├── 创建磁盘临时表
</span></span><span style=display:flex><span>       ├── 分批处理数据
</span></span><span style=display:flex><span>       └── 可能发生文件排序
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3. LIMIT/OFFSET 处理阶段
</span></span><span style=display:flex><span>   ├── 跳过 OFFSET 条记录
</span></span><span style=display:flex><span>   ├── 保留 LIMIT 条记录
</span></span><span style=display:flex><span>   └── 返回最终结果集
</span></span></code></pre></div><p>这种复杂的处理流程，再加上没有明确的 ORDER BY 子句，导致：</p><ol><li>不同的执行路径会产生不同的数据顺序</li><li>相同的查询在不同时刻可能走不同的执行计划</li><li>最终导致分页结果出现重复或遗漏的记录</li></ol><p>因此，在没有明确排序条件的情况下，MySQL 无法保证分页结果的一致性和完整性。这就是为什么我们会看到不同页码之间出现重复数据的根本原因。</p><h2 id=总结>总结</h2><p>通过深入分析 MySQL 的工作原理，我们可以看到：</p><ol><li>数据的物理存储顺序与查询结果顺序是两个独立的概念</li><li>查询优化器的决策直接影响结果的顺序和性能</li><li>正确的索引设计和查询方式是解决问题的关键</li></ol><p>在实际应用中，我们应该：</p><ol><li>始终显式指定排序条件</li><li>根据实际需求选择合适的分页方式</li></ol></section><div class=divider></div><section class=space-y-4><template x-if="['localhost', '127.0.0.1'].indexOf(window.location.hostname) == -1"><article><script src=https://utteranc.es/client.js repo=bestzy6/bestzy6.github.io issue-term=og:title theme=github-light crossorigin=anonymous async></script></article></template></section></article></div><div class="hidden lg:flex lg:flex-col lg:items-end"><nav id=TableOfContents><ul><li><a href=#引言>引言</a></li><li><a href=#问题引出>问题引出</a></li><li><a href=#一mysql的物理存储模型>一、MySQL的物理存储模型</a><ul><li><a href=#11-innodb的聚簇索引结构>1.1 InnoDB的聚簇索引结构</a></li><li><a href=#12-数据页的加载机制>1.2 数据页的加载机制</a></li></ul></li><li><a href=#二查询优化器的决策模型>二、查询优化器的决策模型</a><ul><li><a href=#21-成本估算>2.1 成本估算</a></li><li><a href=#22-执行计划的动态选择>2.2 执行计划的动态选择</a></li></ul></li><li><a href=#三深入分析为什么会出现重复结果>三、深入分析：为什么会出现重复结果？</a><ul><li><a href=#31-执行路径分析>3.1 执行路径分析</a></li><li><a href=#32-结果集的构建过程>3.2 结果集的构建过程</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></div><footer class="flex justify-between items-center gap-2 px-4 py-12"><div><p>© 2025 Bestzy's Blog</p><p class=text-sm>🌱
<span class=text-base-content/60>Powered by <a class=hover:underline href=https://gohugo.io/ target=_blank>Hugo</a> with theme
<a class=hover:underline href=https://github.com/g1eny0ung/hugo-theme-dream target=_blank>Dream</a>.</span></p></div><div x-data="{ icons: [
    { name: 'sunny', status: 'n' },
    { name: 'moon', status: 'y' },
    { name: 'desktop', status: 'auto' }
  ] }" class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"><template x-for="icon in icons"><div role=button tabindex=0 :aria-label="'Select ' + icon.name + ' mode'" class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary" :class="$store.darkMode.icon() === icon.name && 'bg-primary'" @click=$store.darkMode.toggle(icon.status)><ion-icon :name="`${icon.name}-outline`" class=group-hover:text-primary-content :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"></ion-icon></div></template></div></footer></div></div><div class=back><div class=container><div class="dream-grid dream-grid-about"><div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column"><article class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"><div class=card-body><div class=card-title>About Me</div><div class="prose dark:prose-invert"><p>👋 Hi, This is Zheng Yi.</p></div></div></article></div></div><footer class="flex justify-between items-center gap-2 px-4 py-12"><div><p>© 2025 Bestzy's Blog</p><p class=text-sm>🌱
<span class=text-base-content/60>Powered by <a class=hover:underline href=https://gohugo.io/ target=_blank>Hugo</a> with theme
<a class=hover:underline href=https://github.com/g1eny0ung/hugo-theme-dream target=_blank>Dream</a>.</span></p></div><div x-data="{ icons: [
    { name: 'sunny', status: 'n' },
    { name: 'moon', status: 'y' },
    { name: 'desktop', status: 'auto' }
  ] }" class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"><template x-for="icon in icons"><div role=button tabindex=0 :aria-label="'Select ' + icon.name + ' mode'" class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary" :class="$store.darkMode.icon() === icon.name && 'bg-primary'" @click=$store.darkMode.toggle(icon.status)><ion-icon :name="`${icon.name}-outline`" class=group-hover:text-primary-content :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"></ion-icon></div></template></div></footer></div></div></div></div><script>window.lightTheme="emerald",window.darkTheme="forest"</script><script src=https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin=anonymous></script><script src=/js/grid.min.js></script><script src=/js/main.min.js></script><script src=https://cdn.jsdelivr.net/npm/luxon@1.26.0 integrity="sha256-4sbTzmCCW9LGrIh5OsN8V5Pfdad1F1MwhLAOyXKnsE0=" crossorigin=anonymous></script><script>format();function format(){document.querySelectorAll('span[data-format="luxon"]').forEach(e=>{const t=e.textContent;e.textContent=luxon.DateTime.fromISO(t,{locale:"zh"}).toFormat("yyyy年MM月dd日")})}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-BR16XEQ6Y4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BR16XEQ6Y4")}</script><script type=module src=https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.esm.js integrity="sha256-/IFmi82bIhdYWctu0UddSlJqpnzWm7Vh2C4CM32wF/k=" crossorigin=anonymous></script><script nomodule src=https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.js integrity="sha256-mr7eJMX3VC3F7G32mk4oWp1C6a2tlMYxUdptfT7uKI8=" crossorigin=anonymous></script></body></html>